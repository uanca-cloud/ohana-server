# Azure WebPubSub Integration

## Overview

For 2 way communication, we want to enable the Mobile Client and Server to communicate over a WS connection.

This has multiple moving parts:

-   we need an Azure WebPubSub instance and the possibility to connect to it using a WebSocket URL with an access token that will grant temporary access to a logged in user to a group for sending and receiving messages
-   we need an event handler on the server side that will intercept events send from Azure PubSub to the client via WebHooks
-   inside the event handler we want to create a virtual WebSocket server for each connection to enable sending source events through GraphQL Subscriptions

Because of the nature of our Cloud setup, by having multiple server instances running at a time, we are not guaranteed the same instance will receive all requests for a subscription. In this case, we have to use Redis as an external store to keep track of the context for each Virtual WebSocket server and to publish disconnect and complete events so we can react to them on other hosts.

Useful resources:

-   https://learn.microsoft.com/en-us/azure/azure-web-pubsub/howto-develop-eventhandler
-   https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md
-   https://redis.io/docs/latest/develop/interact/pubsub/

### Lifetime of a GQL Subscription

When starting up a subscription we have the following flow:

-   an Upgrade request is sent to the server and a handshake happens
-   connection init event is sent and the server responds with an ack
-   a subscribe message is sent with the GQL payload and the request headers to perform auth checks
-   ping/pong mechanism from the client is keeping the ws connection alive
-   if there is an error or the connection is completed, we want to close the connection

### Azure PubSub Events

Since the client is connecting directly to PubSub, we want to receive events for:

-   connect - the Upgrade request for opening the WS, we need the same protocol as the client here or else it will fail
-   connected - the WS connection is opened and the checks passed, we want to create a virtual WS server at this point to enable GQL subscriptions
-   user event - custom messages, can be any of the messages from the GQL subscription (connection init, ping, source event, etc.). We also need a virtual WS server here, so if one doesn't exist, we need to create it
-   disconnected - after the connection is shut down, this is emitted. We want to publish the event to other hosts for a connection so they can do their own cleanup

If we want to piece it together, we want to use the Azure Web Pub Sub event handler to create a virtual WS server for each connection either for the `connected` event, or for a `user event` coming through on the host for a connection we don't have a WS server created yet. We'll keep track of the WS servers in a `Map` by the connection ID generated by Azure PubSub, so the host can use the Event Emitters and cleanup functions for each specific connection.

We have to use Event Emitters to publish/listen to events between the Azure PubSub Handler and GQL WS server because both libraries use constructors to set up their behaviour.

### A Complete Flow

1. User logs in and requests a WS URL using `getWebSocketUrl`
2. A request is sent to Azure PubSub to open a socket - server gets a `connect` event on the handler to validate the protocol
3. The validation checks pass, the connection between Client and PubSub is opened, a `connected` event is sent to the server on the handler
    - We now create the Virtual WS Server on the host that received the `connected` event, sending the `connection_init` as a user event in PubSub and persisting the context in Redis for an incomplete handshake
    - A random host will get the ack message on the handler as a `user event`, in case we don't have a WS server for this PubSub conenction we create one, but the context is loaded from Redis and will be updated with the completed handshake. A `subscribe` message is now sent through PubSub
    - A random host receives the subscribe message, but because we persist the context in Redis we can perform auth checks on `connectionParams` or open a new WS server if it doesn't exist, but without going through the entire flow again
        - we create an async iterator for each devide id and use Redis PubSub for source events
4. If a host produces a source event, it will be published to Redis and any other host can receive it and send it to the appropriate Client socket
5. In case of a disconnect or complete message we'll do a cleanup on the host that initially received the event and publish using Redis PubSub that other hosts should also destroy the resources related to the connection ID

## Implementation

### GraphQL Subscription

We will need a new subscription field, `watchChat` and a new query field `getWebSocketUrl` that will generate the WS URL for a logged in user

### Server Updates

-   In the `fastify-api/subscriptions` folder we have the code related to the event handler and virtual socket. We need that code there since we need information about both schema and resolver, so keeping it in the `shared` workspace will also require refactoring where we define the schema and resolvers.
    -   the `makeServerless.js` file will ideally live in the `graphql-ws` library in the future so we won't have to worry about maintaining it, since it mirrors the functionality of `makeServer` from the said library, but adds the Redis functions for persisting the context
    -   if the `graphql-ws` library will be updated to include a store for the GQL context, we will want to come back to the `RedisHelper.js` file and do some refactoring based on what their code will look like
    -   `utils.js` will be removed once the `graphql-ws` library will be used for `makeServerless`
-   In `ohana-shared` we have the `pubsub` folder:
    -   `AzurePubSubClient` contains functions that interact with the Azure PubSub SDK
    -   `ChatUpdatePublisher` will be used to write the code for each source event we want to publish. We use Redis PubSub so we can publish even for async iterators listening on other hosts
    -   `PublisherHelper` is a helper function to defer the callback execution to the next event loop block

### Chat Update Types

We will emit updates for:

-   new message being sent
-   read messages
-   the chat is toggled, either in admin or on patient level - 2 different events
-   notification level was changed by the caregiver for the patient

For each of these we will follow the types in the schema:

```graphql
type NewChatMessageUpdate {
    patientId: ID!
    chat: ChatMessage!
    unreadChatMessageCount: Int
}

type ReadChatMessageUpdate {
    patientId: ID!
    orderId: Int!
    unreadChatMessageCount: Int
}

type NotificationLevelUpdate {
    patientId: ID!
    notificationLevel: NotificationLevel
}

type ChatLocationEnabledUpdate {
    locationId: String!
    chatLocationEnabled: Boolean!
}

type ChatPatientEnabledUpdate {
    patientId: ID!
    chatPatientEnabled: Boolean!
}

union ChatUpdate =
      NewChatMessageUpdate
    | ReadChatMessageUpdate
    | ChatLocationEnabledUpdate
    | ChatPatientEnabledUpdate
    | NotificationLevelUpdate
```
