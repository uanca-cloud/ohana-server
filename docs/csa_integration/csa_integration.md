# Server Track Documentation for CSA Integration

This document tracks the server changes required to integrate Voalte Family with CSA.

## Introduction

We will prepare the groundwork for connecting to the CSA both through HTTP and AMQP and enable tenant registration
in RabbitMQ on user login if all prerequisites are met.

## Overview

We will need to add a RabbitMQ cluster in our Ohana infrastructure. We'll also add connection pools and gateways to
communicate with CSA and the RabbitMQ cluster both through HTTP and AMQP. We then add the tenant registration flow
on the caregiver and admin login.

On the login flow, we will check if the tenant short code is found in a Redis collection. This collection will be populated on bootstrap
and an interval to keep it up to date. We'll do that by doing an HTTP request to the RMQ API to get all the
registered exchanges in our Ohana cluster. If the tenant short code is missing from there too, we kick of the tenant registration
process by first checking if we have the proper credentials in an Azure AppConfig service. If we don't, we log and return the login flow
to its previous state to complete. If we have the credentials, we make a call to the `registerTenant` mutation on the CSA GraphQL
endpoint and also create a user, policy and federation upstream for the new tenant in Ohana. If anything fails during this process,
we log the error and return the login flow to its orignal path.

## Implementation

### RabbitMQ

We can work together with the DevOps team to set up the RMQ instance in Terraform. We will manually setup the configuration for
local development through `docker-compose` and a set of config files in the `build/rmq` directory. We will take into account the following:

-   setup docker-compose
-   setup local RabbitMQ json file to persist local users and permissions
-   enable the federation plugin
-   add the admin user and enable the web UI and API

### Env Variables

We will add the configuration keys in the `constants.js` file. The values will be taken from the environment variables, locally
we'll add them in the `sample.env` file, but without sensitive information. We will then have to copy these in the `.env` file
which is ignored by github and can be provided by anyone from the server team. For the cloud deployment, we will add the values
in Terraform and sensitive info like passwords will be stored in Azure KeyVault.

The constants to add are the following:

-   `RABBITMQ_MIN_POOL_SIZE` - represents the minimum size of RabbitMQ connection pools available. Defaults to 1
-   `RABBITMQ_MAX_POOL_SIZE` - represents the max size of RabbitMQ connection pools available. Defaults to 5
-   `RABBITMQ_RESOURCE_MANAGEMENT_URL` - the web interface URL for managing and monitoring the RabbitMQ instance
-   `RABBITMQ_RESOURCE_MANAGEMENT_USER` - the user we’ll use for logging in to the RabbitMQ admin interface
-   `RABBITMQ_RESOURCE_MANAGEMENT_PASS` - the password we’ll use for logging in to the RabbitMQ admin interface
-   `RABBITMQ_CONSUMER_CONNECTION_STRING` - connection string used to consume messages received from the RabbitMQ instance, should be in the format: `amqps://<user>:<password>@<rmq_instance>`
-   `RABBITMQ_INFRA_CONNECTION_STRING` - connection string used to setup exchanges for tenants on the RabbitMQ instance, should be in the format: `amqps://<user>:<password>@<rmq_instance>`
-   `RABBITMQ_HEALTH_CONNECTION_STRING` - connection string used for the health check, to make sure the service is available
-   `HTTP_MIN_POOL_SIZE` - minimum size of HTTP connection pools available. Defaults to 1
-   `HTTP_MAX_POOL_SIZE` - max size of HTTP connection pools available. Defaults to 5
-   `CSA_SUPERGRAPH_URL` - the endpoint we’ll send GraphQL requests to
-   `DISABLE_CSA_INTEGRATION` - feature flag for disabling the integration
-   `CSA_CLIENT_ID` - A unique ID per requesting client which will bin the HTTP requests to the CSA in the `X-Client-ID` header. This value can be generated by the Product and will be used
-   `CSA_PRODUCT_OID` - product OID specific to Ohana, will be used in the `apollographql-client-name` header and as part of the user identity which will be in the format: `hrc:<product_oid>:<uuid>` and sent in the `X-User-Identity` header
-   `CSA_RABBIMQ_CONNECTION_STRING` - will be used to create new federation upstreams for exchanges registered per tenant
-   `APP_CONFIG_CONNECTION_STRING` - will be used in the cloud environment to retrieve tenant credentials via a key pattern
-   `RABBITMQ_POLICY_PREFIX` - should default to `p-csa-`, but we also have the option of changing it
-   `RABBITMQ_FEDERATION_UPSTREAM_PREFIX` - should default to `fu-csa-`, but we also have the option of changing it
-   `RABBITMQ_EXCHANGE_PREFIX` - should default to `from-csa-`, but we also have the option of changing it
-   tenant specific sets of credentials both for communicating with the CSA though the `Autorhization` header and for the RabbitMQ user that will be created. These will follow a pattern that we’ll use to retrieve them in our server app (i.e. `CSA_<tenant_short_code>_HTTP_CREDENTIAL`). We'll use a `tenant.env` file for local development and the AppConfig for cloud environments

### Code Changes:

New files to be added in the `shared/csa` folder:

-   `CsaHttpGateway` - exposes a function that lets us send requests to the CSA supergraph
-   `DefaultSubscriptionHandler` - function to handle incoming RMQ messages from CSA
-   `RabbitMQGateway` - interaction with RabbitMQ through AMQP goes here
-   `RabbitMQHttpApiGateway` - interaction with RabbitMQ through the HTTP API goes here
-   `RabbitMQPoolFactory` - to manage concurrent connections to the RabbitMQ instance - we'll use the `amqplib` npm package

New files in the `shared/tenant` folder:

-   `TenantCsaCredentialDao` - handles credential retrieval and Redis interactions for tenants
-   `TenantCsaDao` - logic for deciding if we should register a tenant and the actual function calls go here
-   `TenantCsaRmqConfigurationDao` - all the checks for RabbitMQ resources through the HTTP API go here
-   `TenantCsaRmqResourceAllocationStrategy` - determines if we need to create RabbitMQ resources for a tenant

New files in the `shared` folder:

-   `DhpHttpGateway` - exposes function to call the DHP API
-   `AzureAppConfigGateway` - function that communicates with the App Config instance to retrieve tenant credentials based on a pattern
-   `LocalAppConfigGateway` - function that communicates performs a check on local env vars to retrieve tenant credentials based on a pattern
-   `HttpPoolFactory` - generic HTTP pool factory to throttle the requests to an HTTP service. Will be used by multiple services

Updates to init the new connection pools on server startup:

-   `shared/bootstrap.js` will be updated to initialize the RMQ and HTTP connection pools **IF NOT CALLED FROM AN AZURE FUNCTION**. We want to keep our azure functions as lightweight as possible.
-   update how the bootstrap function is called to differentiate between fastify and azf context

Updates to remove connections in AMQP on shutdown:

-   add the logic to execute function on the `SIGTERM` event in `fastify-api/server.js`
-   release all the RMQ connection pools on teardown

Additional work:

-   check tenant availability on a set time interval
-   logic to enable/disable this feature based on the value of `DISABLE_CSA_INTEGRATION`
-   update the `caregiverCreateOrRefreshSession` and `adminCreateOrRefreshSession` mutations to reflect the tenant registration flow
-   add a lookup to Catalog Services in `adminCreateOrRefreshSession` for retrieving the tenant short code based on the tenant long code
-   update the `ZenithService` HTTP calls to DHP APIs to use the new connection pool
